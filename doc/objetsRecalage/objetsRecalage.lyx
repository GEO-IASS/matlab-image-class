#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble

\usepackage{fullpage}

\usepackage{textcomp}

\usepackage[numbered, framed]{mcode}
\end_preamble
\use_default_options true
\language french
\inputencoding utf8x
\font_roman default
\font_sans default
\font_typewriter lmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 1
\paragraph_separation indent
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Structures de données pour le recalage d'images
\end_layout

\begin_layout Author
D.
 Legland
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Description des classes définies et implémentées pour tester les algorithmes
 de recalage d'images en 2D et 3D sous Matlab.
 La bibliothèque développée propose des classes pour représenter les images,
 différents modèles de transformation, l'interpolation et le ré-échantillonnage
 des images, des métriques pour comparer les images, et plusieurs algorithmes
 d'optimisation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Inspiration principale : ITK
\end_layout

\begin_layout Standard
idée générale : encapsuler les information, et manipuler les objets en se
 souciant le moins possible de leur implémentation.
\end_layout

\begin_layout Standard
Certaines classes sont indépendantes de la dimension de travail.
 Quand ce n'est pas le cas, la dimension est spécifiée en suffixe du nom.
\end_layout

\begin_layout Chapter
Classe Image
\end_layout

\begin_layout Standard
Les différents outils reposent sur une classe 
\begin_inset Quotes fld
\end_inset

Image
\begin_inset Quotes frd
\end_inset

, qui a pour but de pouvoir gérer :
\end_layout

\begin_layout Itemize
différentes dimensions spatiales d'images : 2D ou 3D, voire 1D (profils)
 ou 0D (une valeur scalaire)
\end_layout

\begin_layout Itemize
différents types de données : des images en niveau de gris, mais aussi des
 images couleur, spectrales, labels, des images de gradients...
\end_layout

\begin_layout Itemize
des images en fonction du temps
\end_layout

\begin_layout Itemize
la calibration spatiale des images, et la conservation de cette calibration
 quand on extrait une coupe 2D d'une image 3D par exemple
\end_layout

\begin_layout Itemize
des informations de calibration de l'affichage (pour les images en niveaux
 de gris)
\end_layout

\begin_layout Standard
Cela fait donc 5 dimensions à gérer, dont 3 dimensions spatiales.
\end_layout

\begin_layout Standard
La classe est utilisable pour des cas classiques (images en niveaux de gris
 en 2D et 3D, images de gradient).
 Il reste cependant encore beaucoup de méthodes non implémentées ou incomplètes,
 elle reste donc à utiliser avec prudence (2010.11.24).
\end_layout

\begin_layout Section
Création
\end_layout

\begin_layout Standard
Pour la création des images, l'idée est de passer par des constructeurs
 statiques.
 Cela permettra à terme de fournir des classes images qui stockent les données
 de manière optimisée.
\end_layout

\begin_layout Standard
On peut créer un nouvel objet grâce à la méthode 
\series bold
create
\series default
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data = imread('cameraman.tif'); % charge un tableau de donnees
\end_layout

\begin_layout Plain Layout

img = Image.create(data);       % convertit en objet image
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La méthode statique 
\series bold
read
\series default
 permet de charger les images de manière générique :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

img = Image.read('cameraman.tif');
\end_layout

\begin_layout Plain Layout

rgb = Image.read('peppers.png');
\end_layout

\end_inset


\end_layout

\begin_layout Section
Visualisation
\end_layout

\begin_layout Standard
Pour afficher une image 2D, on a une méthode show :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

img = Image.read('cameraman.tif');
\end_layout

\begin_layout Plain Layout

img.show();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour représenter une image 3D, on a deux méthodes :
\end_layout

\begin_layout Description
showOrthoSlices affiche 3 coupes orthogonales dans un même repère
\end_layout

\begin_layout Description
showOrthoPlanes affiche 3 coupes orthogonales chacune dans un axe
\end_layout

\begin_layout Chapter
Interpolation et re-échantillonnage
\end_layout

\begin_layout Standard
On a aussi plusieurs classes pour gérer le ré-échantillonnage et l'interpolation
 des images après transformation.
 En particulier, on dispose d'une classe abstraite ImageFunction, qui permet
 de manipuler une image interpolée ou une image après transformation de
 manière transparente.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
un tit schéma
\end_layout

\end_inset


\end_layout

\begin_layout Section
Interfaces et classes abstraites
\end_layout

\begin_layout Subsection
ImageFunction 
\end_layout

\begin_layout Standard
Interface générale pour les classes d'interpolation.
 Elle déclare une méthode d'évaluation de la fonction :
\end_layout

\begin_layout Description

\series bold
evaluate
\series default
 accepte une position (2D ou 3D) en entrée et renvoie une valeur scalaire.
\end_layout

\begin_layout Standard
La classe implémente aussi deux méthodes utilitaires (en accès protégé)
 :
\end_layout

\begin_layout Description
mergeCoordinates pour transformer plusieurs tableaux de coordonnées en un
 seul tableau de points et un paramètre de taille de tablean
\end_layout

\begin_layout Description
splitCoordinates qui fait l'opération inverse de la précédente : le tableau
 de coordonnées est transformé en plusieurs tableaux contenant les coordonnées
 x, y...
 
\end_layout

\begin_layout Subsection
ImageInterpolator
\end_layout

\begin_layout Standard
Classe abstraite, qui encapsule une image, et sert de base aux autres implémenta
tions d'interpolations.
\end_layout

\begin_layout Standard
La classe ImageInterpolator fournit aussi un constructeur statique, 
\begin_inset Quotes fld
\end_inset

create
\begin_inset Quotes frd
\end_inset

, qui prend en argument une image et une chaîne de caractères correspondant
 au type d'interpolation désiré, et qui renvoie un objet d'une classe dérivée.
 Exemple :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

img = Image2D.read('cameraman.tif');
\end_layout

\begin_layout Plain Layout

interpolator = ImageInterpolator.create(img, 'linear');
\end_layout

\begin_layout Plain Layout

class(interpolator)
\end_layout

\begin_layout Plain Layout

ans =
\end_layout

\begin_layout Plain Layout

     LinearInterpolator2D
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ImageInterpolator2D, ImageInterpolator3D 
\end_layout

\begin_layout Standard
Interfaces permettant de typer les classes dérivées.
\end_layout

\begin_layout Section
Implémentations
\end_layout

\begin_layout Standard
Je suis parti au début sur une implémentation par couple type d'interpolation
 - dimension.
 Avoir des interpolateurs génériques selon la dimension requiert plus de
 travail.
 Seule l'interpolation au plus proche voisins est générique pour le moment.
\end_layout

\begin_layout Subsection
NearestNeighborInterpolator
\end_layout

\begin_layout Standard
Interpolation au plus proche voisin.
 Marche en 2D et en 3D, pour des images scalaires et des images de vecteurs
 (chaque composante vectorielle est interpolée individuellement, par une
 approche marginale).
\end_layout

\begin_layout Subsection
LinearInterpolator2D
\end_layout

\begin_layout Standard
Interpolation linéaire pour des images 2D, marche sur des images scalaires.
\end_layout

\begin_layout Subsection
LinearInterpolator3D
\end_layout

\begin_layout Standard
Interpolation linéaire pour des images 3D, marche sur des images scalaires.
\end_layout

\begin_layout Subsection
NearestNeighborGradientEvaluator
\end_layout

\begin_layout Standard
Il s'agit d'une classe d'évaluation du gradient d'une image, qui stocke
 l'image de base, et calcule une interpolation du gradient à chaque appel
 de la fonction evaluate.
 Cette manière de faire permet de travailler sur des images gradient de
 la même manière que si on stockait le gradient interpolé, mais avec un
 coût mémoire moindre.
 Par contre, le temps d'éxécution est plus important.
\end_layout

\begin_layout Section
Classes utilitaires
\end_layout

\begin_layout Standard
Ces classes sont destinées à faciliter la création et la manipulation des
 images transformées ou ré-échantillonnées.
\end_layout

\begin_layout Subsection
ImageResampler 
\end_layout

\begin_layout Standard
Cette classe permet de créer une nouvelle image à partir :
\end_layout

\begin_layout Enumerate
d'une base spatiale (origine + espacement + taille),
\end_layout

\begin_layout Enumerate
et d'un objet de classe 
\begin_inset Quotes fld
\end_inset

ImageFunction
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Subsection
BackwardTransformedImage
\end_layout

\begin_layout Standard
Cette classe qui implémente l'interface 
\begin_inset Quotes fld
\end_inset

ImageFunction
\begin_inset Quotes frd
\end_inset

 encapsule une image et une transformation.
 Quand on évalue la valeur en un point, les coordonnées du point après transform
ation sont calculées, et utilisées pour évaluer la valeur dans l'image stockée.
\end_layout

\begin_layout Section
Implémentation obsolètes
\end_layout

\begin_layout Standard
Ces implémentations étaient utilisées dans des versions précédentes, mais
 des classes plus génériques ont été créées depuis.
\end_layout

\begin_layout Subsection
NearestNeighborInterpolator2D
\end_layout

\begin_layout Standard
Interpolation au plus proche voisin pour des images scalaires 2D.
 Obsolète, remplacée par NearestNeighborInterpolator.
\end_layout

\begin_layout Subsection
NearestNeighborInterpolator3D
\end_layout

\begin_layout Standard
Interpolation au plus proche voisin pour des images scalaires 3D.
 Obsolète, remplacée par NearestNeighborInterpolator.
\end_layout

\begin_layout Chapter
Comparaison des images
\end_layout

\begin_layout Standard
Pour le recalage on a besoin de définir des métriques entre des images,
 ou plus exactement entre des images interpolées.
 Comme on veut calculer des gradients par rapport à une transformation paramétri
que, on prévoit aussi quelques fonctions adéquates.
\end_layout

\begin_layout Standard
Les métriques sont définie par rapport à un ensemble de points de test.
 Un ensemble de points de tests classique est constitué par l'ensemble des
 positions des pixels d'une des deux images.
 Comme on essaie de travailler sur des images interpolées, et donc qui ne
 définissent pas forcément leur base spatiale, l'ensemble de points tests
 est spécifié séparément.
 De plus, cela permet de ne donner qu'un sous-ensemble réduit des points
 (de l'ordre de quelques milliers), et ainsi d'accélérer les temps d'éxécution.
\end_layout

\begin_layout Section
Classes abstraites
\end_layout

\begin_layout Subsection
ImageToImageMetric
\end_layout

\begin_layout Standard
Cette classe stocke trois champs :
\end_layout

\begin_layout Description
img1 une instance de ImageFunction qui représente traditionnellement l'image
 fixe
\end_layout

\begin_layout Description
img2 une instance de ImageFunction qui représente traditionnellement l'image
 mobile
\end_layout

\begin_layout Description
points un ensemble de points de test
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
voir si on remplace pas le tableau de points par un PointGenerator ou une
 structure assimilée
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elle déclare la méthode suivante, qui sera implémentée dans les classes
 dérivées :
\end_layout

\begin_layout Description
computeValue calcule la valeur de la métrique
\end_layout

\begin_layout Standard
Certaines classes devraient aussi implémenter une méthode pour fournir le
 vecteur jacobien par rapport aux paramètres d'une transformation.
 Pour le moment (2010.08.24) il n'y a pas d'interface pour le spécifier.
\end_layout

\begin_layout Description
computeValueAndGradient cette méthode prend en entrée une transformation
 paramétrée ainsi qu'une image gradient.
\end_layout

\begin_layout Section
Implémentation
\end_layout

\begin_layout Standard
Pour le moment une seule implémentation, basée sur la moyenne (ou la somme)
 des carrés des différences, mais avec des noms différents...
\end_layout

\begin_layout Subsection
MeanSquaredDifferencesMetric
\end_layout

\begin_layout Standard
Correspond à une discrétisation de l'intégrale 
\begin_inset Formula \[
MSD=\int\left(I_{1}(x)-I_{2}(x)\right)^{2}dx\]

\end_inset


\end_layout

\begin_layout Standard
En pratique, on passe par une moyenne des carrés des différences.
\end_layout

\begin_layout Standard
Afin de pouvoir calculer des dérivées, elle déclare les champs suivants
 :
\end_layout

\begin_layout Description
transform le modèle de transformation utilisé, qui doit implémenter la méthode
 getJacobian.
\end_layout

\begin_layout Description
gradientImage une image vectorielle représentant typiquement le gradient
 de l'image mobile
\end_layout

\begin_layout Subsubsection
Méthodes implémentées 
\end_layout

\begin_layout Description
computeValue Cette méthode itère sur tous les points tests, évalue la valeur
 correspondante dans chacune des deux images, et calcule la moyenne des
 carrés des différences.
 La moyenne est calculée pour les points qui sont dans les deux images.
\end_layout

\begin_layout Description
computeValueAndGradient cette méthode prend en entrée une transformation
 paramétrée ainsi que les composantes d'une image gradient, et renvoie la
 valeur du vecteur gradient calculée en moyennant, pour les points de test,
 le produit du jacobien de la transformation par l'image gradient.
 L'image gradient est interpolée selon les plus proches voisins.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Question en suspens : que faire avec les points qui tombent en dehors ?
 Pour le moment, je calcule la somme sur les points valides, et divise par
 le nombre total de points.
 Si on divise par le nombre de points valides, on peut avoir une métrique
 plus élevée quand le recalage est meilleur, ce qui est contradictoire...
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SumOfSquaredDifferencesMetric
\end_layout

\begin_layout Standard
Il s'agit principalement d'une ré-implémentation de la précédente.
 Elle renvoie une somme au lieu d'une moyenne.
\end_layout

\begin_layout Section
Autres fonctions de coût
\end_layout

\begin_layout Standard
On a d'autres fonctions de coût, principalement les fonctions de régularisation
 des transformations.
\end_layout

\begin_layout Subsection
MotionRegularizationFunction
\end_layout

\begin_layout Standard
Calcule une valeur qui augmente au fur et à mesure que la transformation
 s'éloigne de l'identité.
 Le coût se décompose en un coût de translation (norme du vecteur) et un
 coût de rotation (norme de l'angle de rotation, en degrés).
\end_layout

\begin_layout Chapter
Transformations géométriques
\end_layout

\begin_layout Standard
En parallèle des classes image, on définit aussi une hiérarchie de classes
 pour les transformations géométriques.
 On a aussi une classe spéciale qui représente une transformation paramétrée.
 Certaines opérations sont définies en fonctions des spécialisations.
\end_layout

\begin_layout Standard
La classe de base est la classe Transform.
 La classe ParametricTransform ajoute la manipulation des paramètres à optimiser.
 On trouve aussi des classes, comme AffineTransform, dont le but est de
 limiter la ré-écriture des transformations spécialisées.
\end_layout

\begin_layout Section
Interfaces et classes abstraites
\end_layout

\begin_layout Subsection
Transform
\end_layout

\begin_layout Standard
Il s'agit de la classe la plus générique.
 Elle définit principalement la méthode transformPoint, ainsi que quelques
 méthodes utilitaires.
\end_layout

\begin_layout Description
transformPoint transforme un point en un autre
\end_layout

\begin_layout Description
transformVector transforme un vecteur en un autre (prend en entrée le vecteur
 en entrée et la position du vecteur)
\end_layout

\begin_layout Description
getJacobian renvoie la matrice jacobienne (matrice des dérivées premières
 en fonction des coordonnées) pour une position donnée
\end_layout

\begin_layout Standard
Toutes ces méthodes sont abstraites, et nécessitent d'être implémentées
 dans les classes dérivées.
 Il est possible aussi de composer les transformations, via la méthode compose.
\end_layout

\begin_layout Description
compose renvoie un nouvelle transformation, résultat de l'application de
 la transformation passée en paramètre suivie de cette transformation
\end_layout

\begin_layout Subsection
ParametricTransform
\end_layout

\begin_layout Standard
Cette classe (abstraite) ajoute la gestion des paramètres.
 Elle définit un champs 
\begin_inset Quotes fld
\end_inset

params
\begin_inset Quotes frd
\end_inset

, sous la forme d'un vecteur ligne, qui peut être modifié via les méthodes
 appropriées.
\end_layout

\begin_layout Standard
Pour distinguer les transformations paramétrées des transformations non
 paramétrées, j'ajoute parfois le suffixe 
\begin_inset Quotes fld
\end_inset

Model
\begin_inset Quotes frd
\end_inset

 au nom de la classe.
 Exemple : 
\begin_inset Quotes fld
\end_inset

TranslationModel
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Méthodes implémentées
\end_layout

\begin_layout Description
getParameters renvoie le vecteur de paramètres
\end_layout

\begin_layout Description
setParameters modifie le vecteur de paramètres
\end_layout

\begin_layout Description
getParameterLength renvoie la taille du vecteur de paramètres
\end_layout

\begin_layout Standard
On a aussi quelques méthodes pour faciliter l'interprétation 
\end_layout

\begin_layout Description
getParameterNames renvoie un tableau de chaînes contenant le noms de chaque
 paramètre
\end_layout

\begin_layout Description
getParameterName renvoie le nom du i-ème paramètre
\end_layout

\begin_layout Standard
Enfin, on a aussi une méthode pour calculer les dérivées mais en fonction
 des paramètres :
\end_layout

\begin_layout Description
getParametricJacobian calcule la matrice jacobienne, qui a autant de lignes
 que le nombre de dimensions spatiales, et autant de colonnes que le nombre
 de paramètres
\end_layout

\begin_layout Subsection
AffineTransform
\end_layout

\begin_layout Standard
Cette classe sert de base abstraite aux autres transformations affines.
 Elle implémente plusieurs méthodes qui se basent sur la matrice de transformati
on associée.
 Notons que la matrice de transformation n'est pas définie dans cette classe,
 mais dans les classes dérivées.
 
\end_layout

\begin_layout Subsubsection*
Méthodes abstraites
\end_layout

\begin_layout Description
getAffineMatrix renvoie la matrice affine associées à cette transformation
\end_layout

\begin_layout Standard
Il s'agit de la seule méthode abstraite de cette classe, et donc la seule
 qui nécessite une implémentation par les classes dérivées.
\end_layout

\begin_layout Subsubsection*
Méthodes implémentées
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Les méthodes suivantes définies par les interfaces sont implémentées par
 la classe AffineTransform :
\end_layout

\begin_layout Description
transformPoint transforme un point en un autre
\end_layout

\begin_layout Description
transformVector transforme un vecteur en un autre
\end_layout

\begin_layout Description
getJacobian renvoie la matrice jacobienne (des dérivées premières en fonction
 des coordonnées) pour une position donnée
\end_layout

\begin_layout Standard
Note : pour une transformation affine, la matrice jacobienne est obtenue
 en isolant la partie linéaire de la matrice de transformation.
\end_layout

\begin_layout Description
compose renvoie un nouvelle transformation, résultat de l'application de
 la transformation passée en paramètre suivie de cette transformation.
 Essaie de renvoyer une transformation affine si possible.
\end_layout

\begin_layout Standard
On a aussi une méthode spécifique aux transformations affines
\end_layout

\begin_layout Description
getInverse renvoie la transformation affine inverse
\end_layout

\begin_layout Section
Modèles de transformation
\end_layout

\begin_layout Standard
Les classes décrites ici permettent de représenter un modèle de transformation
 dont on peut optimiser les paramètres.
 Ces transformations héritent donc à la fois de Transform et de ParametricTransf
orm.
 
\end_layout

\begin_layout Standard
Conventions (par toujours) utilisées :
\end_layout

\begin_layout Itemize
on utilise le suffixe 
\begin_inset Quotes fld
\end_inset

Model
\begin_inset Quotes frd
\end_inset

 ou 
\begin_inset Quotes fld
\end_inset

TransformModel
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Itemize
on utilise le préfixe 
\begin_inset Quotes fld
\end_inset

Centered
\begin_inset Quotes frd
\end_inset

 pour préciser que l'on peut modifier le centre de la transformation.
\end_layout

\begin_layout Itemize
on ajoute le suffixe 2D ou 3D quand la transformation n'est pas générique.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO :
\end_layout

\begin_layout Itemize
peaufiner le choix des conventions de noms pour les transfos
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TranslationModel
\end_layout

\begin_layout Standard
Une translation en dimension arbitaire, définie par un vecteur de translation.
\end_layout

\begin_layout Subsection
CenteredMotionTransform2D
\end_layout

\begin_layout Standard
Il s'agit d'une transformation définie par une rotation autour d'un centre
 donné (par défaut l'origine), suivie d'une translation.
 On a donc 3 paramètres.
 L'angle de rotation est stocké en degrés, et converti en radians pour les
 calculs.
 Le centre de la rotation est un paramètre non optimisable.
\end_layout

\begin_layout Subsection
EulerTransformModel3D (CenteredEulerTransform3D)
\end_layout

\begin_layout Standard
Cette classe représente une transformation rigide obtenue en combinant trois
 rotations successives suivies d'une translation.
 On a donc 6 paramètres.
 
\end_layout

\begin_layout Standard
Il y a de multiples manières de choisir les angles d'Euler.
 Pour cette classe, les rotations sont choisies ainsi, dans cet ordre :
\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{x}$
\end_inset

 selon un angle 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{y}$
\end_inset

 selon un angle 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{z}$
\end_inset

 selon un angle 
\begin_inset Formula $\psi$
\end_inset


\end_layout

\begin_layout Standard
Les angles de rotation sont stockés en degrés et convertis en radian pour
 les calculs.
 Le centre de la rotation est modifiable, mais ne fait pas partie des paramètres
 optimisables.
\end_layout

\begin_layout Subsection
CenteredAffineTransformModel3D
\end_layout

\begin_layout Standard
Représente une transformation affine paramérable.
 Les paramètres sont les 12 coefficients de la matrice de transformation
 (d'abord les coefficients de la première ligne, puis la deuxième...).
\end_layout

\begin_layout Subsection
CenteredQuadTransformModel3D
\end_layout

\begin_layout Standard
Modèle de transformation dans lequel les coordonnées du point transformé
 sont calculées à partir de fonctions quadratiques des coordonnées du point
 d'entrée.
 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
x' & = & p_{1}+p_{4}x+p_{7}y+p_{10}z+p_{13}x^{2}+p_{16}y^{2}+p_{19}z^{2}+p_{22}xy+p_{25}xz+p_{28}yz\\
y' & = & p_{2}+p_{5}x+p_{8}y+p_{11}z+p_{14}x^{2}+p_{17}y^{2}+p_{20}z^{2}+p_{23}xy+p_{26}xz+p_{29}yz\\
z' & = & p{}_{3}+p_{6}x+p_{9}y+p_{12}z+p_{15}x^{2}+p_{18}y^{2}+p_{21}z^{2}+p_{24}xy+p_{27}xz+p_{30}yz\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Le centre de la transformation est initialisé par défaut à (0,0,0).
\end_layout

\begin_layout Section
Implémentations utilitaires
\end_layout

\begin_layout Standard
Les transformations présentées ici servent soit de base à l'implémentation
 de transformations utilisables directement, soit permettent de combiner
 les transformations entre elles.
\end_layout

\begin_layout Subsection
MatrixAffineTransform
\end_layout

\begin_layout Standard
Implémentation classique d'une transformation affine, sous la forme d'une
 matrice.
 Utilisées pour des tests, ou pour implémenter des transformations classiques.
\end_layout

\begin_layout Subsection
CenteredTransformAbstract
\end_layout

\begin_layout Standard
Squelette d'implémentation d'une transformation centrée autour d'un point.
 La classe définit un champ 
\begin_inset Quotes fld
\end_inset

center
\begin_inset Quotes frd
\end_inset

, ainsi qu'un accesseur et un modifieur.
\end_layout

\begin_layout Subsection
ComposedTransform
\end_layout

\begin_layout Standard
Cette classe stocke un tableau de transformations.
 Lors de l'appel à une des méthodes de calcul (par exemple 
\begin_inset Quotes fld
\end_inset

transformPoint
\begin_inset Quotes frd
\end_inset

), elle appelle la méthode correspondante pour chaque transformation stockée,
 et combine les résultats.
 
\end_layout

\begin_layout Standard
Aucune hypothèse n'est faite sur les transformation stockées, elles doivent
 juste hériter de 
\begin_inset Quotes fld
\end_inset

Transform
\begin_inset Quotes frd
\end_inset

, et être définies pour les mêmes dimensions.
\end_layout

\begin_layout Subsection
ComposedTransformModel
\end_layout

\begin_layout Standard
La même que précédemment, mais elle hérite en plus de ParametricTransform.
 Les méthodes de manipulation des paramètres ont été surchargées pour tavailler
 sur les paramètres de la dernière transformation.
\end_layout

\begin_layout Subsection
TransformGradientResampler
\end_layout

\begin_layout Standard
Cette classe est initialisée avec une image.
 Quand on appelle la méthode 
\begin_inset Quotes fld
\end_inset

resample
\begin_inset Quotes frd
\end_inset

 sur une transformation, on obtient une nouvelle image en niveaux de gris
 de la même taille que l'image d'initialisation, et qui contient pour chaque
 pixel ou voxel la valeur locale du déterminant du jacobien de la transformation.
\end_layout

\begin_layout Chapter
Optimisation
\end_layout

\begin_layout Standard
La boîte à outil optimisation de Matlab fournit plusieurs algorithmes d'optimisa
tion.
 Cependant, on peut avoir besoin d'algorithmes non implémentés dans la BAO,
 et l'utilisation des fonctions n'est pas toujours pratique (besoin de beaucoup
 de code et de pointeurs de fonctions).
 On a donc créé des classes dédiées à l'optimisation, qui permettent une
 meilleure modularité.
 
\end_layout

\begin_layout Standard
Note : les noms des classes, champs et méthodes s'inspirent principalement
 d'ITK et de la BAO Optimisation de Matlab.
\end_layout

\begin_layout Section
Interfaces pour l'optimisation
\end_layout

\begin_layout Standard
On définit plusieurs classes d'interfaces, qui spécifient les méthodes à
 implémenter.
 On a principalement une interface pour les algorithmes d'optimisation propremen
t dits, et des interfaces pour manipuler et combiner les fonctions de coût,
 qui peuvent être paramétriques ou non.
\end_layout

\begin_layout Subsection
Optimizer
\end_layout

\begin_layout Standard
La classe Optimizer est une classe abstraite, parente de tous les classes
 implémentant un algorithme d'optimisation.
\end_layout

\begin_layout Subsubsection*
Champs de classe
\end_layout

\begin_layout Standard
La classe Optimizer contient deux champs principaux :
\end_layout

\begin_layout Description
costFunction représente la fonction de coût à optimiser, sous la forme d'un
 pointeur de fonction dont le premier argument est le vecteur de paramètres
\end_layout

\begin_layout Description
params réprésente l'état courant des paramètres
\end_layout

\begin_layout Standard
D'autres champs sont présents pour faciliter la personnalisation :
\end_layout

\begin_layout Description
outputFunction un pointeur de fonction qui est censé être appelé à chaque
 itération
\end_layout

\begin_layout Description
displayMode une chaîne de caractères qui spécifie la quantité d'information
 à afficher.
 Peut être une valeur à choisir parmi 
\begin_inset Quotes fld
\end_inset

off
\begin_inset Quotes frd
\end_inset

 (n'affiche rien - dangereux); 
\begin_inset Quotes fld
\end_inset

iter
\begin_inset Quotes frd
\end_inset

 (affiche le résultat de chaque itération), 
\begin_inset Quotes fld
\end_inset

notify
\begin_inset Quotes frd
\end_inset

 (affiche le résultat si l'algorithme ne converge pas, valeur par défaut),
 ou 
\begin_inset Quotes fld
\end_inset

final
\begin_inset Quotes frd
\end_inset

 (affiche juste le résultat final).
\end_layout

\begin_layout Subsubsection*
Méthode abstraite
\end_layout

\begin_layout Description
startOptimization() démarre l'algorithme d'optimisation jusqu'à ce qu'une
 condition d'arrêt soit atteinte.
 La gestion des conditions d'arrêt (nombre d'itérations, déplacement inférieur
 à un seuil...) est laissée aux classes dérivées.
\end_layout

\begin_layout Subsection
Optimisation via un pointeur de fonction
\end_layout

\begin_layout Standard
La fonction à optimiser est passée sous la forme d'un pointeur de fonction.
 La fonction doit accepter en premier argument le vecteur de paramètres,
 et renvoyer la valeur de la fonction de coût en premier argument de sortie.
 
\end_layout

\begin_layout Standard
Pour les méthodes d'optimisation utilisant le gradient ou la matrice Hessienne,
 Matlab suppose que la fonction renvoie ces paramètres respectivement en
 deuxième et troisième arguments de sortie.
\end_layout

\begin_layout Standard
Dans un cadre de recalage, on a deux actions à accomplir : 
\end_layout

\begin_layout Enumerate
mettre à jour le vecteur de paramètres de l'objet (une transformation, ou
 un groupe de transformations) à optimiser
\end_layout

\begin_layout Enumerate
calculer la valeur d'une métrique qui dépend de l'objet à optimiser.
\end_layout

\begin_layout Standard
On peut utiliser un des pointeurs de fonction suivants :
\end_layout

\begin_layout Description
evaluateParametricMetric(params,
\begin_inset space ~
\end_inset

transfo,
\begin_inset space ~
\end_inset

metric) cette fonction met à jour les paramètres de la transformation, et
 appelle la méthode 
\begin_inset Quotes fld
\end_inset

computeValue
\begin_inset Quotes frd
\end_inset

 de la métrique.
\end_layout

\begin_layout Description
evaluateParametricMetricValueAndGradient la même, mais on évalue aussi le
 gradient.
 Les paramètres additionnels (typiquement, l'image de gradient) sont transmis
 à la méthode 
\begin_inset Quotes fld
\end_inset

computeValue
\begin_inset Quotes frd
\end_inset

 de l'objet métrique.
\end_layout

\begin_layout Subsection
CostFunction
\end_layout

\begin_layout Standard
Il s'agit d'une classe abstraite (interface) qui devrait servir de base
 à la totalité des fonctions de coût.
 La méthode évaluate accepte en entrée un vecteur de paramètres.
 Selon le nombre d'arguments en sortie, cette méthode renvoie une valeur
 scalaire, le gradient, ainsi que la matrice Hessienne.
\end_layout

\begin_layout Description
(abstract)
\begin_inset space ~
\end_inset

evaluate(params) évalue la fonction de coût en fonction du vecteur de paramètres.
 
\end_layout

\begin_layout Standard
On l'utilise via un optimiseur de la manière suivante :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

evaluator = ...
 % cree une instance d'une sous-classe de CostFunction.
\end_layout

\begin_layout Plain Layout

% associe la fonction de cout a l'optimiseur
\end_layout

\begin_layout Plain Layout

fun = @evaluator.evaluate;
\end_layout

\begin_layout Plain Layout

optimizer.setCostFunction(fun);
\end_layout

\end_inset


\end_layout

\begin_layout Section
Objets 
\begin_inset Quotes fld
\end_inset

optimisables
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Le passage par pointeur de fonction n'est pas des plus pratiques, surtout
 quand on travaille avec des fonctions de coût qui combinent plusieurs éléments
 (métrique entre les images, termes de régularisation...).
 L'idée de cette section est de présenter quelques classes qui simplifient
 la création de la fonction de coût.
\end_layout

\begin_layout Subsection
MetricEvaluator
\end_layout

\begin_layout Standard
Il s'agit d'un objet qui encapsule (1) la transformation paramétrique à
 optimiser, et (2) une métrique qui dépend de la transformation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Cree un optimiseur (ici par descente de gradient)
\end_layout

\begin_layout Plain Layout

optimizer = GradientDescentOptimizer();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Cree un evaluateur, a partir de la transfo et de la metrique
\end_layout

\begin_layout Plain Layout

evaluator = MetricEvaluator(transfo2, metric);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% associe la fonction de cout a l'optimiseur
\end_layout

\begin_layout Plain Layout

fun = @evaluator.evaluate;
\end_layout

\begin_layout Plain Layout

optimizer.setCostFunction(fun);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ParametricFunction
\end_layout

\begin_layout Standard
Classe abstraite qui déclare deux méthodes, et implémente la méthode evaluate.
 
\end_layout

\begin_layout Description
(abstract)
\begin_inset space ~
\end_inset

setParameters(params) modifie les paramètres internes
\end_layout

\begin_layout Description
(abstract)
\begin_inset space ~
\end_inset

computeValue() calcule la valeur avec les paramètres courants
\end_layout

\begin_layout Description
evaluate(params) appelle les deux fonctions précédentes, et renvoie la valeur
 courante, ainsi qu'éventuellement le gradient.
\end_layout

\begin_layout Subsection
ParametricObject
\end_layout

\begin_layout Standard
Classe de base (interface) pour les objets paramétriques.
 Les classes dérivées sont les transformations paramétriques, ainsi que
 les agglomérations de transfos.
 Dans ce dernier cas, la modification d'un paramètre est dispatché à la
 transformation concernée.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note : on pourrait éventuellement avoir aussi une classe (abstraite ?) qui
 soit une base pour la gestion des paramètres, et une classe d'interface
 ?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Monitoring de l'optimisation
\end_layout

\begin_layout Standard
On dispose aussi d'un système de gestion d'évènements, qui permet d'actualiser
 l'affichage graphique au cours de la procédure d'optimisation.
 Quelques classes utilitaires pour afficher l'évolution de l'algorithme
 ont aussi été développées.
\end_layout

\begin_layout Subsection
OptimizationListener
\end_layout

\begin_layout Standard
Il s'agit d'une classe abstraite, dont le but est de fournir une implémentation
 minimale pour les méthodes suivantes :
\end_layout

\begin_layout Description
optimizationStarted appelée quand la procédure d'optimisation démarre
\end_layout

\begin_layout Description
optimizationIterated appelée à la fin de chaque itération de la procédure
 d'optimisation
\end_layout

\begin_layout Description
optimizationTerminated appelée lorsque la procédure d'optimisation est terminée
\end_layout

\begin_layout Standard
Les classes dérivées ont ainsi juste à re-implémenter l'une ou la totalité
 de ces méthodes pour avoir un comportement spécifique.
 On ajoute un écouteur à un optimiseur de la façon suivante :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

opt = NelderMeadSimplexOptimizer();
\end_layout

\begin_layout Plain Layout

listener = ...
\end_layout

\begin_layout Plain Layout

opt.addOptimizationListener(listener);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ParametersEvolutionDisplay
\end_layout

\begin_layout Standard
Affiche l'évolution de plusieurs paramètres dans une fenêtre donnée en fonction
 du nombre d'itérations.
\end_layout

\begin_layout Subsection
OptimizedValueListener
\end_layout

\begin_layout Standard
Affiche l'évolution de la valeur actuelle de la fonction d'optimisation
 en fonction du nombre d'itérations.
 Affiche dans un objet axes.
\end_layout

\begin_layout Subsection
ParametricFunctionEvolutionDisplay
\end_layout

\begin_layout Standard
Affiche l'évolution de la valeur courante d'une fonction paramétrique quelconque
 en fonction du nombre d'itérations.
 Affiche dans un objet axes.
\end_layout

\begin_layout Chapter
Algorithmes d'optimisation
\end_layout

\begin_layout Standard
Plusieurs algorithmes d'optimisation ont été implémentés en se basant sur
 l'interface 
\begin_inset Quotes fld
\end_inset

Optimizer
\begin_inset Quotes frd
\end_inset

.
 Il s'agit soit de réécritures complètes, soit d'encapsulation de fonctions
 de la boîte à outils optimization de Matlab.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO :
\end_layout

\begin_layout Itemize
uniformiser la construction des optimiseurs 
\end_layout

\begin_deeper
\begin_layout Itemize
pas d'argument (nécessite initialisation ultérieure)
\end_layout

\begin_layout Itemize
fonction à optimiser et vecteur de départ (permet construction en une ligne)
\end_layout

\end_deeper
\begin_layout Itemize
uniformiser la gestion de la verbosité
\end_layout

\begin_layout Itemize
Mieux gérer les conditions d'arrêt :
\end_layout

\begin_deeper
\begin_layout Itemize
précision en x
\end_layout

\begin_layout Itemize
précision en f
\end_layout

\begin_layout Itemize
max_fun_eval
\end_layout

\begin_layout Itemize
max_iter (pour les algos itératifs)
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Section
Optimisation basée sur la valeur de la fonction
\end_layout

\begin_layout Standard
Les algorithmes de cette catégorie ne nécessitent de connaître que la fonction
 de coût.
 Leur vitesse de convergence est en général faible.
 La classe la plus pratique pour le moment est GaussianLinearSearchOptimizer.
\end_layout

\begin_layout Subsection
MultiLinearSearchOptimizer
\end_layout

\begin_layout Standard
Cet algorithme recherche le minimum d'une fonction en utilisant plusieurs
 recherches linéaires.
 Implémenté en utilisant la recherche de Brent.
 On peut spécifier l'ensemble des directions de recherche (par défaut :
 recherche dans la direction de chaque paramètre individuel, et dans les
 directions de couples de paramètres).
\end_layout

\begin_layout Subsection
BoundedMultiLinearOptimizer 
\end_layout

\begin_layout Standard
Algorithme basique 
\begin_inset Quotes fld
\end_inset

maison
\begin_inset Quotes frd
\end_inset

.
 Le principe est similaire à la recherche linéaire multiple, mais selon
 un principe différent.
 On définit (1) les bornes de variations pour chaque paramètre et (2) le
 nombre de points de test entre ces bornes.
 On itère ensuite en générant des valeurs différentes pour un paramètre
 à la fois, et en gardant la valeur qui minimise la fonction de coût.
\end_layout

\begin_layout Description
Avantage simple à mettre en oeuvre
\end_layout

\begin_layout Description
Inconvénients assez lente, et ne permet pas de réduire la précision de manière
 incrémentale
\end_layout

\begin_layout Subsection
GaussianLinearSearchOptimizer
\end_layout

\begin_layout Standard
Un autre algorithme 
\begin_inset Quotes fld
\end_inset

maison
\begin_inset Quotes frd
\end_inset

 basé sur la recherche linéaire.
 Cette fois ci, les valeurs de rechrche pour chaque paramètre sont générées
 en utilisant une distribution gaussienne centrée sur la dernière meilleure
 valeur trouvée, et avec une variance que l'on peut préciser.
\end_layout

\begin_layout Description
Avantages assez rapide, et se prête bien à une recherche multi-précision,
 par exemple en divisant la variance de chaque paramètre par un facteur
 constant au bout d'un nombre suffisant d'itérations.
\end_layout

\begin_layout Description
Inconvénients nécessite encore beaucoup d'évaluation de la fonction de coût,
 et risque de minima non trouvés si on cherche paramètre après paramètre
\end_layout

\begin_layout Subsection
NelderMeadSimplexOptimizer
\end_layout

\begin_layout Standard
Implémentation de l'algorithme du simplexe basée sur le livre Numerical
 Recipes (3ème édition).
 Permet de spécifier le delta initial dans chaque direction.
\end_layout

\begin_layout Standard
Rappel : on utilise un tableau de taille 
\begin_inset Formula $(n+1)*n$
\end_inset

 pour stocker les coordonnées des sommets du simplexe.
 La méthode est donc plus appropriée pour des problèmes présentant un petit
 nombre de paramètres.
\end_layout

\begin_layout Subsection
MatlabSimplexOptimizer
\end_layout

\begin_layout Standard
Cet algorithme recherche le minimum d'une fonction (supposée convexe) par
 la méthode du simplexe de Nelder-Mead.
 En pratique, il s'agit d'une encapsulation de la fonction 
\begin_inset Quotes fld
\end_inset

fminsearch
\begin_inset Quotes frd
\end_inset

 de Matlab.
\end_layout

\begin_layout Standard
Un défaut de la fonction fminsearch est qu'on ne peut pas spécifier la taille
 initiale du simplexe, ce qui fait que la recherche se fait dans un domaine
 trop étroit.
 A l'usage, on se retrouve assez vite dans des minima locaux.
 Il vaut donc mieux lui préférer la classe NelderMeadSimplexOptimizer, qui
 permet de spécifier la taille, voire la position du simplexe initial.
\end_layout

\begin_layout Section
Optimisation utilisant le gradient
\end_layout

\begin_layout Standard
Plusieurs algorithmes utilisent le gradient des fonctions de coût pour accélerer
 la recherche de l'optimum.
 Pour le moment, seul l'algorithme de descente de gradient est implémenté,
 mais Matlab en propose d'autres.
\end_layout

\begin_layout Subsection
GradientDescentOptimizer
\end_layout

\begin_layout Standard
L'idée de cet algorithme est de se déplacer à chaque itération dans la direction
 inverse du gradient.
 La gradient impose la direction, mais le pas est fixé par l'algorithme,
 en général une fonction décroissante du nombre d'itérations.
\end_layout

\begin_layout Standard
Champs à renseigner :
\end_layout

\begin_layout Description
nIter le nombre max d'itération
\end_layout

\begin_layout Description
step0 l'amplitude du pas de déplacement à la première itération
\end_layout

\begin_layout Description
tau la taux de décroissance du pas de déplacement
\end_layout

\begin_layout Standard
On peut ensuite avoir des variantes de la descente de gradient, par exemple
 en utilisant une descente stochastique de gradient (on retire les points
 d'évaluation à chaque itération).
\end_layout

\begin_layout Chapter
Perspectives
\end_layout

\begin_layout Standard
La bibliothèque est encore largement en développement, mais est déjà fonctionnel
le.
\end_layout

\begin_layout Standard
Parmi les points à développer ultérieurement :
\end_layout

\begin_layout Itemize
la création de paquetages, afin d'organiser un peu mieux les classes
\end_layout

\begin_layout Itemize
la gestion des images couleurs
\end_layout

\begin_layout Itemize
gérer l'information mutuelle sous forme de classe
\end_layout

\end_body
\end_document
