#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble

\usepackage{fullpage}

\usepackage{textcomp}

\usepackage[numbered, framed]{mcode}
\end_preamble
\use_default_options true
\language french
\inputencoding utf8x
\font_roman default
\font_sans default
\font_typewriter lmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
OOLIP : bibliothèque de classes pour le recalage d'images sous Matlab
\end_layout

\begin_layout Author
D.
 Legland
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Description des classes définies et implémentées pour tester les algorithmes
 de recalage d'images en 2D et 3D sous Matlab.
 La bibliothèque développée propose des classes pour représenter les images,
 différents modèles de transformation, l'interpolation et le ré-échantillonnage
 des images, des métriques pour comparer les images, et plusieurs algorithmes
 d'optimisation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Inspiration principale : ITK
\end_layout

\begin_layout Standard
idée générale : encapsuler les information, et manipuler les objets en se
 souciant le moins possible de leur implémentation.
\end_layout

\begin_layout Standard
Certaines classes sont indépendantes de la dimension de travail.
 Quand ce n'est pas le cas, la dimension est spécifiée en suffixe du nom.
\end_layout

\begin_layout Section
Classe Image
\end_layout

\begin_layout Standard
Les différents outils reposent sur une classe 
\begin_inset Quotes fld
\end_inset

Image
\begin_inset Quotes frd
\end_inset

, qui a pour but de pouvoir gérer :
\end_layout

\begin_layout Itemize
des images métricielles 2D ou 3D
\end_layout

\begin_layout Itemize
éventuellement vectorielles
\end_layout

\begin_layout Itemize
éventuellement fonction du temps
\end_layout

\begin_layout Itemize
avec une calibration spatiale
\end_layout

\begin_layout Standard
Cela fait donc 5 dimensions à gérer, dont 3 dimensions spatiales.
\end_layout

\begin_layout Standard
On trouve quelques méthodes statiques pour créer les images en utilisant
 la classe appropriée :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

img = Image2D.read('cameraman.tif');
\end_layout

\begin_layout Plain Layout

img.show();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il reste cependant encore beaucoup de méthodes non implémentées ou incomplètes
 (2010.11.24).
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Transformations géométriques
\end_layout

\begin_layout Standard
En parallèle des classes image, on définit aussi une hiérarchie de classes
 pour les transformations géométriques.
 On a aussi une classe spéciale qui représente une transformation paramétrée.
 Certaines opérations sont définies en fonctions des spécialisations.
\end_layout

\begin_layout Standard
La classe de base est la classe Transform.
 La classe ParametricTransform ajoute la manipulation des paramètres à optimiser.
 On trouve aussi des classes, comme AffineTransform, dont le but est de
 limiter la ré-écriture des transformations spécialisées.
\end_layout

\begin_layout Subsection
Interfaces et classes abstraites
\end_layout

\begin_layout Subsubsection
Transform
\end_layout

\begin_layout Standard
Il s'agit de la classe la plus générique.
 Elle définit principalement la méthode transformPoint, ainsi que quelques
 méthodes utilitaires.
\end_layout

\begin_layout Description
transformPoint transforme un point en un autre
\end_layout

\begin_layout Description
transformVector transforme un vecteur en un autre (prend en entrée le vecteur
 en entrée et la position du vecteur)
\end_layout

\begin_layout Description
getJacobian renvoie la matrice jacobienne (matrice des dérivées premières
 en fonction des coordonnées) pour une position donnée
\end_layout

\begin_layout Standard
Toutes ces méthodes sont abstraites, et nécessitent d'être implémentées
 dans les classes dérivées.
 Il est possible aussi de composer les transformations, via la méthode compose.
\end_layout

\begin_layout Description
compose renvoie un nouvelle transformation, résultat de l'application de
 la transformation passée en paramètre suivie de cette transformation
\end_layout

\begin_layout Subsubsection
ParametricTransform
\end_layout

\begin_layout Standard
Cette classe (abstraite) ajoute la gestion des paramètres.
 Elle définit un champs 
\begin_inset Quotes fld
\end_inset

params
\begin_inset Quotes frd
\end_inset

, sous la forme d'un vecteur ligne, qui peut être modifié via les méthodes
 appropriées.
\end_layout

\begin_layout Standard
Pour distinguer les transformations paramétrées des transformations non
 paramétrées, j'ajoute parfois le suffixe 
\begin_inset Quotes fld
\end_inset

Model
\begin_inset Quotes frd
\end_inset

 au nom de la classe.
 Exemple : 
\begin_inset Quotes fld
\end_inset

TranslationModel
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Paragraph*
Méthodes implémentées
\end_layout

\begin_layout Description
getParameters renvoie le vecteur de paramètres
\end_layout

\begin_layout Description
setParameters modifie le vecteur de paramètres
\end_layout

\begin_layout Description
getParameterLength renvoie la taille du vecteur de paramètres
\end_layout

\begin_layout Standard
On a aussi quelques méthodes pour faciliter l'interprétation 
\end_layout

\begin_layout Description
getParameterNames renvoie un tableau de chaînes contenant le noms de chaque
 paramètre
\end_layout

\begin_layout Description
getParameterName renvoie le nom du i-ème paramètre
\end_layout

\begin_layout Standard
Enfin, on a aussi une méthode pour calculer les dérivées mais en fonction
 des paramètres :
\end_layout

\begin_layout Description
getParametricJacobian calcule la matrice jacobienne, qui a autant de lignes
 que le nombre de dimensions spatiales, et autant de colonnes que le nombre
 de paramètres
\end_layout

\begin_layout Subsubsection
AffineTransform
\end_layout

\begin_layout Standard
Cette classe sert de base abstraite aux autres transformations affines.
 Elle implémente plusieurs méthodes qui se basent sur la matrice de transformati
on associée.
 Notons que la matrice de transformation n'est pas définie dans cette classe,
 mais dans les classes dérivées.
 
\end_layout

\begin_layout Paragraph*
Méthodes abstraites
\end_layout

\begin_layout Description
getAffineMatrix renvoie la matrice affine associées à cette transformation
\end_layout

\begin_layout Standard
Il s'agit de la seule méthode abstraite de cette classe, et donc la seule
 qui nécessite une implémentation par les classes dérivées.
\end_layout

\begin_layout Paragraph*
Méthodes implémentées
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Les méthodes suivantes définies par les interfaces sont implémentées par
 la classe AffineTransform :
\end_layout

\begin_layout Description
transformPoint transforme un point en un autre
\end_layout

\begin_layout Description
transformVector transforme un vecteur en un autre
\end_layout

\begin_layout Description
getJacobian renvoie la matrice jacobienne (des dérivées premières en fonction
 des coordonnées) pour une position donnée
\end_layout

\begin_layout Standard
Note : pour une transformation affine, la matrice jacobienne est obtenue
 en isolant la partie linéaire de la matrice de transformation.
\end_layout

\begin_layout Description
compose renvoie un nouvelle transformation, résultat de l'application de
 la transformation passée en paramètre suivie de cette transformation.
 Essaie de renvoyer une transformation affine si possible.
\end_layout

\begin_layout Standard
On a aussi une méthode spécifique aux transformations affines
\end_layout

\begin_layout Description
getInverse renvoie la transformation affine inverse
\end_layout

\begin_layout Subsection
Modèles de transformation
\end_layout

\begin_layout Standard
Les classes décrites ici permettent de représenter un modèle de transformation
 dont on peut optimiser les paramètres.
 Ces transformations héritent donc à la fois de Transform et de ParametricTransf
orm.
 
\end_layout

\begin_layout Standard
Conventions (par toujours) utilisées :
\end_layout

\begin_layout Itemize
on utilise le suffixe 
\begin_inset Quotes fld
\end_inset

Model
\begin_inset Quotes frd
\end_inset

 ou 
\begin_inset Quotes fld
\end_inset

TransformModel
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Itemize
on utilise le préfixe 
\begin_inset Quotes fld
\end_inset

Centered
\begin_inset Quotes frd
\end_inset

 pour préciser que l'on peut modifier le centre de la transformation.
\end_layout

\begin_layout Itemize
on ajoute le suffixe 2D ou 3D quand la transformation n'est pas générique.
\end_layout

\begin_layout Subsubsection
TranslationModel
\end_layout

\begin_layout Standard
Une translation en dimension arbitaire, définie par un vecteur de translation.
\end_layout

\begin_layout Subsubsection
CenteredMotionTransform2D
\end_layout

\begin_layout Standard
Il s'agit d'une transformation définie par une rotation autour d'un centre
 donné (par défaut l'origine), suivie d'une translation.
 On a donc 3 paramètres.
 L'angle de rotation est stocké en degrés, et converti en radians pour les
 calculs.
 Le centre de la rotation est un paramètre non optimisable.
\end_layout

\begin_layout Subsubsection
CenteredEulerTransform3D
\end_layout

\begin_layout Standard
Cette classe représente une transformation rigide obtenue en combinant trois
 rotations successives suivies d'une translation.
 On a donc 6 paramètres.
 
\end_layout

\begin_layout Standard
Il y a de multiples manières de choisir les angles d'Euler.
 Pour cette classe, les rotations sont choisies ainsi, dans cet ordre :
\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{x}$
\end_inset

 selon un angle 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{y}$
\end_inset

 selon un angle 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\begin_layout Enumerate
une rotation autour de l'angle 
\begin_inset Formula $O_{z}$
\end_inset

 selon un angle 
\begin_inset Formula $\psi$
\end_inset


\end_layout

\begin_layout Standard
Les angles de rotation sont stockés en degré et convertis en radian pour
 les calculs.
 Le centre de la rotation est modifiable, mais ne fait pas partie des paramètres
 optimisables.
\end_layout

\begin_layout Subsubsection
CenteredAffineTransformModel3D
\end_layout

\begin_layout Standard
Représente une transformation affine paramérable.
 Les paramètres sont les 12 coefficients de la matrice de transformation
 (d'abord les coefficients de la première ligne, puis la deuxième...).
\end_layout

\begin_layout Subsubsection
CenteredQuadTransformModel3D
\end_layout

\begin_layout Standard
Modèle de transformation dans lequel les coordonnées du point transformé
 sont calculées à partir de fonctions quadratiques des coordonnées du point
 d'entrée.
 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
x' & = & p_{1}+p_{4}x+p_{7}y+p_{10}z+p_{13}x^{2}+p_{16}y^{2}+p_{19}z^{2}+p_{22}xy+p_{25}xz+p_{28}yz\\
y' & = & p_{2}+p_{5}x+p_{8}y+p_{11}z+p_{14}x^{2}+p_{17}y^{2}+p_{20}z^{2}+p_{23}xy+p_{26}xz+p_{29}yz\\
z' & = & p{}_{3}+p_{6}x+p_{9}y+p_{12}z+p_{15}x^{2}+p_{18}y^{2}+p_{21}z^{2}+p_{24}xy+p_{27}xz+p_{30}yz\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Le centre de la transformation est initialisé par défaut à (0,0,0).
\end_layout

\begin_layout Subsection
Implémentations utilitaires
\end_layout

\begin_layout Subsubsection
MatrixAffineTransform
\end_layout

\begin_layout Standard
Implémentation classique d'une transformation affine, sous la forme d'une
 matrice.
 Utilisées pour des tests, ou pour implémenter des transformations classiques.
\end_layout

\begin_layout Subsubsection
ComposedTransform
\end_layout

\begin_layout Standard
Cette classe stocke un tableau de transformations.
 Lors de l'appel à une des méthodes de calcul (par exemple 
\begin_inset Quotes fld
\end_inset

transformPoint
\begin_inset Quotes frd
\end_inset

), elle appelle la méthode correspondante pour chaque transformation stockée,
 et combine les résultats.
 
\end_layout

\begin_layout Standard
Aucune hypothèse n'est faite sur les transformation stockées, elles doivent
 juste hériter de 
\begin_inset Quotes fld
\end_inset

Transform
\begin_inset Quotes frd
\end_inset

, et être définies pour les mêmes dimensions.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Interpolation et re-échantillonnage
\end_layout

\begin_layout Standard
On a aussi plusieurs classes pour gérer le ré-échantillonnage et l'interpolation
 des images après transformation.
\end_layout

\begin_layout Subsection
Interfaces et classes abstraites
\end_layout

\begin_layout Description
ImageFunction interface générale pour les classes d'interpolation.
 Elle définit une méthode accepte une position (2D ou 3D) en entrée et renvoie
 une valeur scalaire
\end_layout

\begin_layout Description
ImageInterpolator interface d'interpolation, qui se base sur une image.
\end_layout

\begin_layout Description
ImageInterpolator2D,
\begin_inset space ~
\end_inset

ImageInterpolator3D interfaces permettant de typer les classes dérivées
\end_layout

\begin_layout Standard
La classe ImageInterpolator fournit aussi un constructeur statique, 
\begin_inset Quotes fld
\end_inset

create
\begin_inset Quotes frd
\end_inset

, qui prend en argument une image et une chaîne de caractères correspondant
 au type d'interpolation désiré, et qui renvoie un objet d'une classe dérivée.
 Exemple :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

img = Image2D.read('cameraman.tif');
\end_layout

\begin_layout Plain Layout

inter = ImageInterpolator.create(img, 'linear');
\end_layout

\begin_layout Plain Layout

class(inter)
\end_layout

\begin_layout Plain Layout

ans =
\end_layout

\begin_layout Plain Layout

     LinearInterpolator2D
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implémentations
\end_layout

\begin_layout Standard
Pour le moment on a une implémentation par couple type d'interpolation -
 dimension.
 Il n'est pas forcément plus efficace d'avoir des interpolateurs génériques.
\end_layout

\begin_layout Description
NearestNeighborInterpolator2D
\end_layout

\begin_layout Description
NearestNeighborInterpolator3D
\end_layout

\begin_layout Description
LinearInterpolator2D
\end_layout

\begin_layout Description
LinearInterpolator3D
\end_layout

\begin_layout Subsection
Classes utilitaires
\end_layout

\begin_layout Standard
Ces classes sont destinées à faciliter la création et la manipulation des
 images transformées ou ré-échantillonnées.
\end_layout

\begin_layout Subsubsection
ImageResampler 
\end_layout

\begin_layout Standard
Cette classe permet de créer une nouvelle image à partir :
\end_layout

\begin_layout Enumerate
d'une base spatiale (origine + espacement + taille),
\end_layout

\begin_layout Enumerate
et d'un objet de classe 
\begin_inset Quotes fld
\end_inset

ImageFunction
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Subsubsection
BackwardTransformedImage
\end_layout

\begin_layout Standard
Cette classe qui implémente l'interface 
\begin_inset Quotes fld
\end_inset

ImageFunction
\begin_inset Quotes frd
\end_inset

 encapsule une image et une transformation.
 Quand on évalue la valeur en un point, les coordonnées du point après transform
ation sont calculées, et utilisées pour évaluer la valeur dans l'image stockée.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Comparaison des images
\end_layout

\begin_layout Standard
Pour le recalage on a besoin de définir des métriques entre des images,
 ou plus exactement entre des images interpolées.
\end_layout

\begin_layout Standard
Les métriques sont définie par rapport à un ensemble de points de test.
 Un ensemble de points de tests classique est constitué par l'ensemble des
 positions des pixels d'une des deux images.
 Comme on essaie de travailler sur des images interpolées, et donc qui ne
 définissent pas forcément leur base spatiale, l'ensemble de points tests
 est spécifié séparément.
\end_layout

\begin_layout Subsection
Classes abstraites
\end_layout

\begin_layout Subsubsection
ImageToImageMetric
\end_layout

\begin_layout Standard
Cette classe stocke trois champs :
\end_layout

\begin_layout Description
img1 une instance de ImageFunction qui représente traditionnellement l'image
 fixe
\end_layout

\begin_layout Description
img2 une instance de ImageFunction qui représente traditionnellement l'image
 mobile
\end_layout

\begin_layout Description
points un ensemble de points de test
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
voir si on remplace pas le tableau de points par un PointGenerator ou une
 structure assimilée
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elle déclare la méthode suivante, qui sera implémentée dans les classes
 dérivées :
\end_layout

\begin_layout Description
computeValue calcule la valeur de la métrique
\end_layout

\begin_layout Standard
Certaines classes devraient aussi implémenter une méthode pour fournir le
 vecteur jacobien par rapport aux paramètres d'une transformation.
 Pour le moment (2010.08.24) il n'y a pas d'interface pour le spécifier.
\end_layout

\begin_layout Description
computeValueAndGradient cette méthode prend en entrée une transformation
 paramétrée ainsi qu'une image gradient.
\end_layout

\begin_layout Subsection
Implémentation
\end_layout

\begin_layout Standard
Pour le moment une seule implémentation, basée sur la moyenne (ou la somme)
 des carrés des différences, mais avec des noms différents...
\end_layout

\begin_layout Subsubsection
MeanSquaredDifferencesMetric
\end_layout

\begin_layout Standard
Correspond à une discrétisation de l'intégrale 
\begin_inset Formula \[
MSD=\int\left(I_{1}(x)-I_{2}(x)\right)^{2}dx\]

\end_inset


\end_layout

\begin_layout Standard
En pratique, on passe par une moyenne des carrés des différences.
\end_layout

\begin_layout Standard
Afin de pouvoir calculer des dérivées, elle déclare les champs suivants
 :
\end_layout

\begin_layout Description
transform le modèle de transformation utilisé, qui doit implémenter la méthode
 getJacobian.
\end_layout

\begin_layout Description
gradientImage une image vectorielle représentant typiquement le gradient
 de l'image mobile
\end_layout

\begin_layout Paragraph
Méthodes implémentées 
\end_layout

\begin_layout Description
computeValue Cette méthode itère sur tous les points tests, évalue la valeur
 correspondante dans chacune des deux images, et calcule la moyenne des
 carrés des différences.
 La moyenne est calculée pour les points qui sont dans les deux images.
\end_layout

\begin_layout Description
computeValueAndGradient cette méthode prend en entrée une transformation
 paramétrée ainsi que les composantes d'une image gradient, et renvoie la
 valeur du vecteur gradient calculée en moyennant, pour les points de test,
 le produit du jacobien de la transformation par l'image gradient.
 L'image gradient est interpolée selon les plus proches voisins.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Question en suspens : que faire avec les points qui tombent en dehors ?
 Pour le moment, je calcule la somme sur les points valides, et divise par
 le nombre total de points.
 Si on divise par le nombre de points valides, on peut avoir une métrique
 plus élevée quand le recalage est meilleur, ce qui est contradictoire...
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
SumOfSquaredDifferencesMetric
\end_layout

\begin_layout Standard
Il s'agit principalement d'une ré-implémentation de la précédente.
 Elle renvoie une somme au lieu d'une moyenne.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Optimisation de la fonction de coût
\end_layout

\begin_layout Standard
La boîte à outil optimisation de Matlab fournit plusieurs algorithmes d'optimisa
tion.
 Cependant, on peut avoir besoin d'algorithmes non implémentés dans la BAO,
 et l'utilisation des fonctions n'est pas toujours pratique (besoin de beaucoup
 de code et de pointeurs de fonctions).
 On a donc créé des classes dédiée à l'optimisation, qui permettent une
 meilleure modularité.
 
\end_layout

\begin_layout Standard
Note : les noms des classes, champs et méthodes s'inspirent principalement
 d'ITK et de la BAO Optimisation de Matlab.
\end_layout

\begin_layout Subsection
Interfaces
\end_layout

\begin_layout Subsubsection
Optimizer
\end_layout

\begin_layout Standard
La classe Optimizer définit un algorithme d'optimisation.
 Elle contient deux champs principaux :
\end_layout

\begin_layout Description
costFunction qui représente la fonction de coût à optimiser
\end_layout

\begin_layout Description
params qui réprésente l'état courant des paramètres
\end_layout

\begin_layout Standard
D'autres champs sont présents pour faciliter la personnalisation :
\end_layout

\begin_layout Description
outputFunction un pointeur de fonction qui est censé être appelé à chaque
 itération
\end_layout

\begin_layout Description
displayMode une chaîne de caractères qui spécifie la quantité d'information
 à afficher à chaque étape
\end_layout

\begin_layout Paragraph*
Méthode abstraite
\end_layout

\begin_layout Description
startOptimization démarre l'algorithme d'optimisation jusqu'à ce qu'une
 condition d'arrêt soit atteinte.
 La gestion des conditions d'arrêt (nombre d'itération, déplacement inférieur
 à un seuil...) est laissée aux classes dérivées.
\end_layout

\begin_layout Subsubsection
Fonction à optimiser
\end_layout

\begin_layout Standard
La fonction à optimiser est passée sous la forme d'un pointeur de fonction.
 La fonction doit accepter en premier argument le vecteur de paramètres,
 et renvoyer la valeur de la fonction de coût en premier argument de sortie.
 
\end_layout

\begin_layout Standard
Pour les méthodes d'optimisation utilisant le gradient ou la matrice Hessienne,
 Matlab suppose que la fonction renvoie ces paramètres respectivement en
 deuxième et troisième arguments de sortie.
\end_layout

\begin_layout Standard
Dans un cadre de recalage, on a deux actions à accomplir : 
\end_layout

\begin_layout Enumerate
mettre à jour le vecteur de paramètres de l'objet (une transformation, ou
 un groupe de transformations) à optimiser
\end_layout

\begin_layout Enumerate
calculer la valeur d'une métrique qui dépend de l'objet à optimiser.
\end_layout

\begin_layout Standard
On peut utiliser un des pointeurs de fonction suivants :
\end_layout

\begin_layout Description
evaluateParametricMetric(params,
\begin_inset space ~
\end_inset

transfo,
\begin_inset space ~
\end_inset

metric) cette fonction met à jour les paramètres de la transformation, et
 appelle la méthode 
\begin_inset Quotes fld
\end_inset

computeValue
\begin_inset Quotes frd
\end_inset

 de la métrique.
\end_layout

\begin_layout Description
evaluateParametricMetricValueAndGradient la même, mais on évalue aussi le
 gradient.
 Les paramètres additionnels (typiquement, l'image de gradient) sont transmis
 à la méthode 
\begin_inset Quotes fld
\end_inset

computeValue
\begin_inset Quotes frd
\end_inset

 de l'objet métrique.
\end_layout

\begin_layout Subsubsection
MetricEvaluator
\end_layout

\begin_layout Standard
Il s'agit d'un objet qui encapsule (1) la transformation paramétrique à
 optimiser, et (2) une métrique qui dépend de la transformation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Cree un optimiseur (ici par descente de gradient)
\end_layout

\begin_layout Plain Layout

optimizer = GradientDescentOptimizer();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Cree un evaluateur, a partir de la transfo et de la metrique
\end_layout

\begin_layout Plain Layout

evaluator = MetricEvaluator(transfo2, metric);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% associe la fonction de cout a l'optimiseur
\end_layout

\begin_layout Plain Layout

fun = @evaluator.evaluate;
\end_layout

\begin_layout Plain Layout

optimizer.setCostFunction(fun);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Optimisation basée sur la valeur de la fonction
\end_layout

\begin_layout Standard
Les algorithmes de cette catégorie ne nécessitent de connaître que la fonction
 de coût.
 Leur vitesse de convergence est en général faible.
\end_layout

\begin_layout Subsubsection
NelderMeadSimplexOptimizer
\end_layout

\begin_layout Standard
Cet algorithme recherche le minimum d'une fonction (supposée convexe) par
 la méthode du simplexe de Nelder-Mead.
 En pratique, il s'agit d'une encapsulation de la fonction 
\begin_inset Quotes fld
\end_inset

fminsearch
\begin_inset Quotes frd
\end_inset

 de Matlab.
\end_layout

\begin_layout Standard
A l'usage, il semble que l'on se retrouve assez vite dans des minima locaux.
\end_layout

\begin_layout Subsubsection
MultiLinearSearchOptimizer
\end_layout

\begin_layout Standard
Cet algorithme recherche le minimum d'une fonction en utilisant plusieurs
 recherches linéaires.
 Implémenté en utilisant la recherche de Brent.
 On peut spécifier l'ensemble des directions de recherche (par défaut :
 recherche dans la direction de chaque paramètre individuel, et dans les
 directions de couples de paramètres).
\end_layout

\begin_layout Subsection
Optimisation utilisant le gradient
\end_layout

\begin_layout Standard
Plusieurs algorithmes utilisent le gradient des fonctions de coût pour accélerer
 la recherche de l'optimum.
 Pour le moment, seul l'algorithme de descente de gradient est implémenté.
\end_layout

\begin_layout Subsubsection
GradientDescentOptimizer
\end_layout

\begin_layout Standard
L'idée de cet algorithme est de se déplacer à chaque itération dans la direction
 inverse du gradient.
 La gradient impose la direction, mais le pas est fixé par l'algorithme,
 en général une focntion décroissante du nombre d'itérations.
\end_layout

\begin_layout Standard
Champs à renseigner :
\end_layout

\begin_layout Description
nIter le nombre max d'itération
\end_layout

\begin_layout Description
step0 l'amplitude du pas de déplacement
\end_layout

\begin_layout Description
tau la taux de décroissance du pas de déplacement
\end_layout

\begin_layout Subsection
Monitoring de l'optimization
\end_layout

\begin_layout Standard
On dispose aussi d'un système de gestion d'évènements, qui permet d'actualiser
 l'affichage graphique au cours de la procédure d'optimisation.
 Quelques classes utilitaires pour afficher l'évolution de l'algorithme
 ont aussi été développées.
\end_layout

\begin_layout Subsubsection
OptimizationListener
\end_layout

\begin_layout Standard
Il s'agit d'une classe abstraite, dont le but est de fournir une implémentation
 minimale pour les méthodes suivantes :
\end_layout

\begin_layout Description
optimizationStarted appelée quand la procédure d'optimisation démarre
\end_layout

\begin_layout Description
optimizationIterated appelée à la fin de chaque itération de la procédure
 d'optimisation
\end_layout

\begin_layout Description
optimizationTerminated appelée lorsque la procédure d'optimisation est terminée
\end_layout

\begin_layout Standard
Les classes dérivées ont ainsi juste à re-implémenter l'une ou la totalité
 de ces méthodes pour avoir un comportement spécifique.
 On ajoute un listener à un optimiseur de la façon suivante :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

opt = NelderMeadSimplexOptimizer();
\end_layout

\begin_layout Plain Layout

listener = ...
\end_layout

\begin_layout Plain Layout

opt.addOptimizationListener(listener);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
ParametersEvolutionDisplay
\end_layout

\begin_layout Standard
Affiche l'évolution de plusieurs paramètres dans une fenêtre donnée en fonction
 du nombre d'itérations.
\end_layout

\begin_layout Subsubsection
OptimizedValueListener
\end_layout

\begin_layout Standard
Affiche l'évolution de la valeur actuelle de la fonction d'otpimisation
 en fonction du nombre d'itérations.
 Affiche dans un objet axes.
\end_layout

\begin_layout Subsubsection
ParametricFunctionEvolutionDisplay
\end_layout

\begin_layout Standard
Affiche l'évolution de la valeur courante d'une fonction paramétrique quelconque
 en fonction du nombre d'itérations.
 Affiche dans un objet axes.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Perspectives
\end_layout

\begin_layout Standard
La bibliothèque encore largement en développement.
 
\end_layout

\begin_layout Standard
Parmi les points à développer ultérieurement :
\end_layout

\begin_layout Itemize
la création de paquetages, afin d'organiser un peu mieux les classes
\end_layout

\begin_layout Itemize
la gestion des images couleurs
\end_layout

\begin_layout Itemize
gérer l'information mutuelle sous forme de classe
\end_layout

\end_body
\end_document
